"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const dayjs_1 = __importDefault(require("dayjs"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
class Logger {
    constructor(ctx) {
        this.level = {
            success: 'green',
            info: 'blue',
            warn: 'yellow',
            error: 'red'
        };
        this.ctx = ctx;
    }
    handleLog(type, msg) {
        // if configPath is invalid then this.ctx.config === undefined
        // if not then check config.silent
        if (this.ctx.getConfig() === undefined || !this.ctx.getConfig('silent')) {
            let log = chalk_1.default[this.level[type]](`[PicGo ${type.toUpperCase()}]: `);
            log += msg;
            console.log(log);
            process.nextTick(() => {
                this.handleWriteLog(type, msg, this.ctx);
            });
            return msg;
        }
        else {
            return;
        }
    }
    handleWriteLog(type, msg, ctx) {
        try {
            const logLevel = this.ctx.getConfig('settings.logLevel');
            const logPath = this.ctx.getConfig('settings.logPath') || path_1.default.join(ctx.baseDir, './picgo.log');
            if (this.checkLogLevel(type, logLevel)) {
                const picgoLog = fs_extra_1.default.createWriteStream(logPath, { flags: 'a', encoding: 'utf8' });
                let log = `${dayjs_1.default().format('YYYY-MM-DD HH:mm:ss')} [PicGo ${type.toUpperCase()}] ${msg}`;
                let logger = new console.Console(picgoLog);
                if (typeof msg === 'object' && type === 'error') {
                    log += `\n------Error Stack Begin------\n${util_1.default.format(msg.stack)}\n-------Error Stack End-------`;
                }
                logger.log(log);
                picgoLog.destroy();
                logger = null;
            }
        }
        catch (e) {
            console.log(e);
        }
    }
    checkLogLevel(type, level) {
        if (level === undefined || level === 'all') {
            return true;
        }
        if (Array.isArray(level)) {
            return level.some((item) => (item === type || item === 'all'));
        }
        else {
            return type === level;
        }
    }
    success(msg) {
        return this.handleLog('success', msg);
    }
    info(msg) {
        return this.handleLog('info', msg);
    }
    error(msg) {
        return this.handleLog('error', msg);
    }
    warn(msg) {
        return this.handleLog('warn', msg);
    }
}
exports.default = Logger;
